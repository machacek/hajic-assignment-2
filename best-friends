#!/usr/bin/env python3

# Std library imports
import argparse
from collections import Counter, deque
from math import log2

def parse_args():
    
    parser = argparse.ArgumentParser(
            description="Finds best word association pairs using the pointwise mutual information method.",
            epilog="Author: Matous Machacek <machacekmatous@gmail.com>",
            )

    parser.add_argument("input",
            help="An input file with words (one word per line)",
            type=argparse.FileType('r')
            )

    return parser.parse_args()

def n_gram_iterator(iterable, n=2):
    iterator = iter(iterable)
    actual_n_gram = deque()

    # fill the first n items to deque
    for _ in range(n):
        actual_n_gram.append(next(iterator))

    while True:
        yield tuple(actual_n_gram)
        actual_n_gram.append(next(iterator))
        actual_n_gram.popleft()


def main(): 
    args = parse_args()

    # Get the bigrams iterator
    stripped = (line.strip() for line in args.input)
    bigrams = n_gram_iterator(stripped, n=2)

    # First, we are going to count all bigrams, first positions and second positions
    bigram_count = Counter(bigrams)
    first_position_count = Counter(bigram[0] for bigram in bigram_count.elements())
    second_position_count = Counter(bigram[1] for bigram in bigram_count.elements())

    N = sum(first_position_count.values())

    # Second, let's remove less frequent words
    for bigram in list(bigram_count.keys()):
        first, second = bigram
        if first_position_count[first] < 10:
            del first_position_count[first]
            del bigram_count[bigram]
        if second_position_count[second] < 10:
            del second_position_count[second]
            del bigram_count[bigram]

    # Third, compute the probabilities
    bigram_prob = { bigram : count/N for bigram, count in bigram_count.items() }
    first_position_prob = { first : count/N for first, count in first_position_count.items() }
    second_position_prob = { second : count/N for second, count in second_position_count.items() }

    # Finally compute the point wise mutuall informations
    PMI = Counter()
    for bigram, prob in bigram_prob.items():
        first, second = bigram
        PMI[bigram] = log2(prob) - log2(first_position_prob[first]) - log2(second_position_prob[second])

    for bigram, pmi in PMI.most_common():
        #print(bigram, pmi, bigram_count[bigram], first_position_count[bigram[0]], second_position_count[bigram[1]], bigram_count[bigram]/(first_position_count[bigram[0]] * second_position_count[bigram[1]]))
        print(" ".join(bigram), pmi, sep='\t')

if __name__ == '__main__':
    main()
