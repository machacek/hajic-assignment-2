#!/usr/bin/env python3

# Std library imports
import argparse
from collections import Counter, deque
from math import log2

def parse_args():
    
    parser = argparse.ArgumentParser(
            description="Finds best word association pairs using the pointwise mutual information method.",
            epilog="Author: Matous Machacek <machacekmatous@gmail.com>",
            )

    parser.add_argument("input",
            help="An input file with words (one word per line)",
            type=argparse.FileType('r')
            )

    return parser.parse_args()

def n_gram_iterator(iterable, n=2):
    iterator = iter(iterable)
    actual_n_gram = deque()

    # fill the first n items to deque
    for _ in range(n):
        actual_n_gram.append(next(iterator))

    while True:
        yield tuple(actual_n_gram)
        actual_n_gram.append(next(iterator))
        actual_n_gram.popleft()

def compute_PMI(events_iterable):
    # First, we are going to count all bigrams, first positions and second positions
    pair_count = Counter(events_iterable)
    first_position_count = Counter(pair[0] for pair in pair_count.elements())
    second_position_count = Counter(pair[1] for pair in pair_count.elements())

    N = sum(first_position_count.values())

    # Second, let's remove less frequent words
    for pair in list(pair_count.keys()):
        first, second = pair
        if first_position_count[first] < 10:
            del first_position_count[first]
            del pair_count[pair]
        if second_position_count[second] < 10:
            del second_position_count[second]
            del pair_count[pair]

    # Third, compute the probabilities
    pair_prob = { pair : count/N for pair, count in pair_count.items() }
    first_position_prob = { first : count/N for first, count in first_position_count.items() }
    second_position_prob = { second : count/N for second, count in second_position_count.items() }

    # Finally compute the point wise mutuall informations
    PMI = Counter()
    for pair, prob in pair_prob.items():
        first, second = pair
        PMI[pair] = log2(prob) - log2(first_position_prob[first]) - log2(second_position_prob[second])

    return PMI

def main(): 
    args = parse_args()

    # Get the bigrams iterator
    stripped = (line.strip() for line in args.input)
    bigrams = n_gram_iterator(stripped, n=2)

    PMI = compute_PMI(bigrams)

    for pair, pmi in PMI.most_common():
        print(pair, pmi)

if __name__ == '__main__':
    main()
