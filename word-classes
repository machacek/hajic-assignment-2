#!/usr/bin/env python3

# Std library imports
import argparse
from itertools import combinations
from collections import defaultdict, Counter
from math import log2

def parse_args():
    
    parser = argparse.ArgumentParser(
            description="Compute the word classed for given input",
            epilog="Author: Matous Machacek <machacekmatous@gmail.com>",
            )

    parser.add_argument("input",
            help="An input file with words (one word per line)",
            type=argparse.FileType('r')
            )

    return parser.parse_args()

def n_gram_generator(iterable, n=2):
    iterator = iter(iterable)
    actual_n_gram = deque()

    # fill the first n items to deque
    for _ in range(n):
        actual_n_gram.append(next(iterator))

    while True:
        yield tuple(actual_n_gram)
        actual_n_gram.append(next(iterator))
        actual_n_gram.popleft()

class MergableClass(object):
    def __new__(cls, first, second=None):
        if isinstance(first, str) and second is None:
            return cls.MergableClassLeafeNode(first)
        elif isinstance(first, cls.MergableClassBase) and isinstance(second, cls.MergableClassBase):
            return cls.MergableClassInnerNode(sorted((first, second), key=hash))
        else:
            raise TypeError("Constructor accepts one string or two MergableClasses")

    class MergableClassBase(object):
        def __or__(self, other):
            return MergableClass(self, other)

        def merge(self, other):
            return MergableClass(self, other)

    class MergableClassLeafeNode(str, MergableClassBase):
        pass

    class MergableClassInnerNode(tuple, MergableClassBase):
        pass

class SparseMatrixCounter(object):
    def __init__(self, iterable=None):
        self.rows = defaultdict(Counter)
        self.collumns = defaultdict(Counter)

        if iterable is not None:
            self.update(iterable)

    def update(self, iterable):
        if isinstance(iterable, dict): 
            for (x,y), value in iterable.items():
                self.add(x,y,value)
        else:
            for x, y in iterable:
                self.add(x,y,1)
    
    def __set__(self, index, value):
        row_index, collumn_index = index
        self.rows[row_index][collumn_index]     = value
        self.collumns[collumn_index][row_index] = value
    
    def __get__(self, index):
        row_index, collumn_index = index
        return self.rows.get(row_index, Counter())[collumn_index]

    def add(self, row_index, collumn_index, n=1)
        self.rows[row_index][collumn_index]     += n
        self.collumns[collumn_index][row_index] += n

    def get_row(self, row_index):
        return self.rows.get(row_index, Counter())
    
    def get_collumn(self, collumn_index):
        return self.collumns.get(collumn_index, Counter())
    
    def pop_row(self, row_index):
        row = self.rows.pop(row_index, Counter())
        for collumn_index in row:
            del self.collumns[collumn_index][row_index]
        return row
    
    def pop_collumn(self, collumn_index):
        collumn = self.collumns.pop(collumn_index, Counter())
        for row_index in collumn:
            del self.rows[row_index][collumn_index]
        return collumn

    def insert_row(self, row_index, row):
        self.pop_row(row_index)
        self.rows[row_index] = row
        for collumn_index, value in row.items():
            self.collumns[collumn_index][row_index] = value
    
    def insert_collumn(self, collumn_index, collumn):
        self.pop_collumn(collumn_index)
        self.collumns[collumn_index] = collumn
        for row_index, value in collumn.items():
            self.rows[row_index][collumn_index] = value

    def items(self):
        for row_index, row in self.rows.items():
            for collumn_index, value in row.items():
                index = (row_index, collumn_index)
                yield index, value 

    def __iter__(self):
        for row_index, row in self.rows.items():
            for collumn_index in row:
                yield row_index, collumn_index

class WordClasses(object):
    def __init__(self, words):

        # Load the data
        classes = list(MergableClass(word) for word in words) 
        bigrams = list(n_gram_generator(classes, 2))

        # Initialize data structures
        self.class_set = {classes}
        self.N = len(bigrams)
        self.bigrams_counter = SparseMatrixCounter(bigrams)
        self.left_counter = Counter(left for left, right in bigrams)
        self.right_counter = Counter(right for left, right in bigrams)
        self.bigrams_logs = SparseMatrixCounter({
            bigram : self.bigrams_counter[bigram] / self.N * log2(self.N * self.bigrams_counter[bigram] / (self.left_counter[bigram[0]] * self.right_counter[bigram[1]]))
            for bigram in self.bigrams_counter 
            })

    def merge(self, cls_1, cls_2):
        "Merge the classes and update data structures"
        merged = cls_1 | cls_2

        # Update current set of classes
        self.class_set.remove(cls_1)
        self.class_set.remove(cls_2)
        self.class_set.add(merged)

        # Update bigram count table
        merged_row = self.bigrams_counter.pop_row(cls_1) + self.bigrams_counter.pop_row(cls2)
        self.bigrams_counter.insert_row(merged, merged_row)
        merged_collumn = self.bigrams_counter.pop_collumn(cls_1) + self.bigrams_counter.pop_collumn(cls2)
        self.bigrams_counter.insert_collumn(merged, merged_collumn)

        # Update marginal counts
        self.left_counter[merged] = self.left_counter.pop(cls_1,0) + self.left_counter.pop(cls_2,0)
        self.right_counter[merged] = self.right_counter.pop(cls_1,0) + self.right_counter.pop(cls_2,0)

    def best_merge(self):
        "return the tuple of classes with highest MI change"
        return max(combinations(self.class_set), key=self.compute_MI_delta)

    def compute_MI_delta(self, to_be_merged):
        "for given two classes, computes the change of MI after merge"
        k, l = to_be_merged
        ...









def main(): 
    args = parse_args()

    words = (line.strip() for line in args.input)

    table = SmartTable(words)



if __name__ == '__main__':
    main()
